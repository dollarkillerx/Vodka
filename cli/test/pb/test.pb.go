// Code generated by protoc-gen-go. DO NOT EDIT.
// source: test.proto

package pb

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type RespOk struct {
	SuccessId            int32    `protobuf:"varint,1,opt,name=success_id,json=successId,proto3" json:"success_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RespOk) Reset()         { *m = RespOk{} }
func (m *RespOk) String() string { return proto.CompactTextString(m) }
func (*RespOk) ProtoMessage()    {}
func (*RespOk) Descriptor() ([]byte, []int) {
	return fileDescriptor_c161fcfdc0c3ff1e, []int{0}
}

func (m *RespOk) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RespOk.Unmarshal(m, b)
}
func (m *RespOk) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RespOk.Marshal(b, m, deterministic)
}
func (m *RespOk) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RespOk.Merge(m, src)
}
func (m *RespOk) XXX_Size() int {
	return xxx_messageInfo_RespOk.Size(m)
}
func (m *RespOk) XXX_DiscardUnknown() {
	xxx_messageInfo_RespOk.DiscardUnknown(m)
}

var xxx_messageInfo_RespOk proto.InternalMessageInfo

func (m *RespOk) GetSuccessId() int32 {
	if m != nil {
		return m.SuccessId
	}
	return 0
}

type RespError struct {
	ErrorId              int32    `protobuf:"varint,1,opt,name=error_id,json=errorId,proto3" json:"error_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RespError) Reset()         { *m = RespError{} }
func (m *RespError) String() string { return proto.CompactTextString(m) }
func (*RespError) ProtoMessage()    {}
func (*RespError) Descriptor() ([]byte, []int) {
	return fileDescriptor_c161fcfdc0c3ff1e, []int{1}
}

func (m *RespError) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RespError.Unmarshal(m, b)
}
func (m *RespError) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RespError.Marshal(b, m, deterministic)
}
func (m *RespError) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RespError.Merge(m, src)
}
func (m *RespError) XXX_Size() int {
	return xxx_messageInfo_RespError.Size(m)
}
func (m *RespError) XXX_DiscardUnknown() {
	xxx_messageInfo_RespError.DiscardUnknown(m)
}

var xxx_messageInfo_RespError proto.InternalMessageInfo

func (m *RespError) GetErrorId() int32 {
	if m != nil {
		return m.ErrorId
	}
	return 0
}

type Req struct {
	Msg                  string   `protobuf:"bytes,1,opt,name=msg,proto3" json:"msg,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Req) Reset()         { *m = Req{} }
func (m *Req) String() string { return proto.CompactTextString(m) }
func (*Req) ProtoMessage()    {}
func (*Req) Descriptor() ([]byte, []int) {
	return fileDescriptor_c161fcfdc0c3ff1e, []int{2}
}

func (m *Req) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Req.Unmarshal(m, b)
}
func (m *Req) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Req.Marshal(b, m, deterministic)
}
func (m *Req) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Req.Merge(m, src)
}
func (m *Req) XXX_Size() int {
	return xxx_messageInfo_Req.Size(m)
}
func (m *Req) XXX_DiscardUnknown() {
	xxx_messageInfo_Req.DiscardUnknown(m)
}

var xxx_messageInfo_Req proto.InternalMessageInfo

func (m *Req) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

type Resp struct {
	Msg string `protobuf:"bytes,1,opt,name=msg,proto3" json:"msg,omitempty"`
	// Types that are valid to be assigned to Resp:
	//	*Resp_RespOk
	//	*Resp_RespError
	Resp                 isResp_Resp `protobuf_oneof:"Resp"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *Resp) Reset()         { *m = Resp{} }
func (m *Resp) String() string { return proto.CompactTextString(m) }
func (*Resp) ProtoMessage()    {}
func (*Resp) Descriptor() ([]byte, []int) {
	return fileDescriptor_c161fcfdc0c3ff1e, []int{3}
}

func (m *Resp) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Resp.Unmarshal(m, b)
}
func (m *Resp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Resp.Marshal(b, m, deterministic)
}
func (m *Resp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Resp.Merge(m, src)
}
func (m *Resp) XXX_Size() int {
	return xxx_messageInfo_Resp.Size(m)
}
func (m *Resp) XXX_DiscardUnknown() {
	xxx_messageInfo_Resp.DiscardUnknown(m)
}

var xxx_messageInfo_Resp proto.InternalMessageInfo

func (m *Resp) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

type isResp_Resp interface {
	isResp_Resp()
}

type Resp_RespOk struct {
	RespOk *RespOk `protobuf:"bytes,2,opt,name=RespOk,proto3,oneof"`
}

type Resp_RespError struct {
	RespError *RespError `protobuf:"bytes,3,opt,name=RespError,proto3,oneof"`
}

func (*Resp_RespOk) isResp_Resp() {}

func (*Resp_RespError) isResp_Resp() {}

func (m *Resp) GetResp() isResp_Resp {
	if m != nil {
		return m.Resp
	}
	return nil
}

func (m *Resp) GetRespOk() *RespOk {
	if x, ok := m.GetResp().(*Resp_RespOk); ok {
		return x.RespOk
	}
	return nil
}

func (m *Resp) GetRespError() *RespError {
	if x, ok := m.GetResp().(*Resp_RespError); ok {
		return x.RespError
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Resp) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Resp_RespOk)(nil),
		(*Resp_RespError)(nil),
	}
}

func init() {
	proto.RegisterType((*RespOk)(nil), "test.RespOk")
	proto.RegisterType((*RespError)(nil), "test.RespError")
	proto.RegisterType((*Req)(nil), "test.Req")
	proto.RegisterType((*Resp)(nil), "test.Resp")
}

func init() { proto.RegisterFile("test.proto", fileDescriptor_c161fcfdc0c3ff1e) }

var fileDescriptor_c161fcfdc0c3ff1e = []byte{
	// 232 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe2, 0xe2, 0x2a, 0x49, 0x2d, 0x2e,
	0xd1, 0x2b, 0x28, 0xca, 0x2f, 0xc9, 0x17, 0x62, 0x01, 0xb1, 0x95, 0xd4, 0xb9, 0xd8, 0x82, 0x52,
	0x8b, 0x0b, 0xfc, 0xb3, 0x85, 0x64, 0xb9, 0xb8, 0x8a, 0x4b, 0x93, 0x93, 0x53, 0x8b, 0x8b, 0xe3,
	0x33, 0x53, 0x24, 0x18, 0x15, 0x18, 0x35, 0x58, 0x83, 0x38, 0xa1, 0x22, 0x9e, 0x29, 0x4a, 0x6a,
	0x5c, 0x9c, 0x20, 0x85, 0xae, 0x45, 0x45, 0xf9, 0x45, 0x42, 0x92, 0x5c, 0x1c, 0xa9, 0x20, 0x06,
	0x42, 0x25, 0x3b, 0x98, 0xef, 0x99, 0xa2, 0x24, 0xce, 0xc5, 0x1c, 0x94, 0x5a, 0x28, 0x24, 0xc0,
	0xc5, 0x9c, 0x5b, 0x9c, 0x0e, 0x96, 0xe4, 0x0c, 0x02, 0x31, 0x95, 0x2a, 0xb9, 0x58, 0x40, 0x06,
	0x60, 0xca, 0x08, 0xa9, 0xc1, 0xdc, 0x20, 0xc1, 0xa4, 0xc0, 0xa8, 0xc1, 0x6d, 0xc4, 0xa3, 0x07,
	0x76, 0x26, 0x44, 0xcc, 0x83, 0x21, 0x08, 0xe6, 0x42, 0x7d, 0x24, 0x27, 0x48, 0x30, 0x83, 0x95,
	0xf2, 0x23, 0x94, 0x82, 0x85, 0x3d, 0x18, 0x82, 0x10, 0x6a, 0x9c, 0xd8, 0x20, 0x56, 0x1a, 0xf5,
	0x32, 0x72, 0xb1, 0x07, 0xa7, 0x16, 0x95, 0x65, 0x26, 0xa7, 0x0a, 0xc9, 0x72, 0xb1, 0x04, 0x95,
	0xe6, 0x19, 0x0a, 0x71, 0xc2, 0x74, 0x16, 0x4a, 0x71, 0x21, 0x0c, 0x11, 0x92, 0x07, 0x4b, 0x1b,
	0xe1, 0x90, 0x36, 0x60, 0x84, 0x2a, 0x30, 0xc6, 0xa1, 0x40, 0x83, 0x51, 0x48, 0x11, 0xac, 0xc0,
	0x04, 0xa7, 0x02, 0x03, 0xc6, 0x24, 0x36, 0x70, 0x0c, 0x18, 0x03, 0x02, 0x00, 0x00, 0xff, 0xff,
	0x2b, 0x8b, 0x01, 0xa8, 0x8f, 0x01, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// ServiceClient is the client API for Service service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ServiceClient interface {
	Run1(ctx context.Context, in *Req, opts ...grpc.CallOption) (*Resp, error)
	Run2(ctx context.Context, in *Req, opts ...grpc.CallOption) (Service_Run2Client, error)
	Run3(ctx context.Context, opts ...grpc.CallOption) (Service_Run3Client, error)
	Run4(ctx context.Context, opts ...grpc.CallOption) (Service_Run4Client, error)
}

type serviceClient struct {
	cc *grpc.ClientConn
}

func NewServiceClient(cc *grpc.ClientConn) ServiceClient {
	return &serviceClient{cc}
}

func (c *serviceClient) Run1(ctx context.Context, in *Req, opts ...grpc.CallOption) (*Resp, error) {
	out := new(Resp)
	err := c.cc.Invoke(ctx, "/test.Service/Run1", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serviceClient) Run2(ctx context.Context, in *Req, opts ...grpc.CallOption) (Service_Run2Client, error) {
	stream, err := c.cc.NewStream(ctx, &_Service_serviceDesc.Streams[0], "/test.Service/Run2", opts...)
	if err != nil {
		return nil, err
	}
	x := &serviceRun2Client{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Service_Run2Client interface {
	Recv() (*Resp, error)
	grpc.ClientStream
}

type serviceRun2Client struct {
	grpc.ClientStream
}

func (x *serviceRun2Client) Recv() (*Resp, error) {
	m := new(Resp)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *serviceClient) Run3(ctx context.Context, opts ...grpc.CallOption) (Service_Run3Client, error) {
	stream, err := c.cc.NewStream(ctx, &_Service_serviceDesc.Streams[1], "/test.Service/Run3", opts...)
	if err != nil {
		return nil, err
	}
	x := &serviceRun3Client{stream}
	return x, nil
}

type Service_Run3Client interface {
	Send(*Req) error
	CloseAndRecv() (*Resp, error)
	grpc.ClientStream
}

type serviceRun3Client struct {
	grpc.ClientStream
}

func (x *serviceRun3Client) Send(m *Req) error {
	return x.ClientStream.SendMsg(m)
}

func (x *serviceRun3Client) CloseAndRecv() (*Resp, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(Resp)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *serviceClient) Run4(ctx context.Context, opts ...grpc.CallOption) (Service_Run4Client, error) {
	stream, err := c.cc.NewStream(ctx, &_Service_serviceDesc.Streams[2], "/test.Service/Run4", opts...)
	if err != nil {
		return nil, err
	}
	x := &serviceRun4Client{stream}
	return x, nil
}

type Service_Run4Client interface {
	Send(*Req) error
	Recv() (*Resp, error)
	grpc.ClientStream
}

type serviceRun4Client struct {
	grpc.ClientStream
}

func (x *serviceRun4Client) Send(m *Req) error {
	return x.ClientStream.SendMsg(m)
}

func (x *serviceRun4Client) Recv() (*Resp, error) {
	m := new(Resp)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// ServiceServer is the server API for Service service.
type ServiceServer interface {
	Run1(context.Context, *Req) (*Resp, error)
	Run2(*Req, Service_Run2Server) error
	Run3(Service_Run3Server) error
	Run4(Service_Run4Server) error
}

// UnimplementedServiceServer can be embedded to have forward compatible implementations.
type UnimplementedServiceServer struct {
}

func (*UnimplementedServiceServer) Run1(ctx context.Context, req *Req) (*Resp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Run1 not implemented")
}
func (*UnimplementedServiceServer) Run2(req *Req, srv Service_Run2Server) error {
	return status.Errorf(codes.Unimplemented, "method Run2 not implemented")
}
func (*UnimplementedServiceServer) Run3(srv Service_Run3Server) error {
	return status.Errorf(codes.Unimplemented, "method Run3 not implemented")
}
func (*UnimplementedServiceServer) Run4(srv Service_Run4Server) error {
	return status.Errorf(codes.Unimplemented, "method Run4 not implemented")
}

func RegisterServiceServer(s *grpc.Server, srv ServiceServer) {
	s.RegisterService(&_Service_serviceDesc, srv)
}

func _Service_Run1_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Req)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServiceServer).Run1(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/test.Service/Run1",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServiceServer).Run1(ctx, req.(*Req))
	}
	return interceptor(ctx, in, info, handler)
}

func _Service_Run2_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Req)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ServiceServer).Run2(m, &serviceRun2Server{stream})
}

type Service_Run2Server interface {
	Send(*Resp) error
	grpc.ServerStream
}

type serviceRun2Server struct {
	grpc.ServerStream
}

func (x *serviceRun2Server) Send(m *Resp) error {
	return x.ServerStream.SendMsg(m)
}

func _Service_Run3_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(ServiceServer).Run3(&serviceRun3Server{stream})
}

type Service_Run3Server interface {
	SendAndClose(*Resp) error
	Recv() (*Req, error)
	grpc.ServerStream
}

type serviceRun3Server struct {
	grpc.ServerStream
}

func (x *serviceRun3Server) SendAndClose(m *Resp) error {
	return x.ServerStream.SendMsg(m)
}

func (x *serviceRun3Server) Recv() (*Req, error) {
	m := new(Req)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Service_Run4_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(ServiceServer).Run4(&serviceRun4Server{stream})
}

type Service_Run4Server interface {
	Send(*Resp) error
	Recv() (*Req, error)
	grpc.ServerStream
}

type serviceRun4Server struct {
	grpc.ServerStream
}

func (x *serviceRun4Server) Send(m *Resp) error {
	return x.ServerStream.SendMsg(m)
}

func (x *serviceRun4Server) Recv() (*Req, error) {
	m := new(Req)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _Service_serviceDesc = grpc.ServiceDesc{
	ServiceName: "test.Service",
	HandlerType: (*ServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Run1",
			Handler:    _Service_Run1_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Run2",
			Handler:       _Service_Run2_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "Run3",
			Handler:       _Service_Run3_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "Run4",
			Handler:       _Service_Run4_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "test.proto",
}
